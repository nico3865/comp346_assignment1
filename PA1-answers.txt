===================================================================================
task 1: Atomicity violation

explanation: reading and writing is not done in the right order.
they are critical sections, so should be atomic.

bugs: account.withdraw(10); and account.debosit(10); should be 
performed atomically in the depositor and withdrawer classes, or better: 
in the Account class.

===================================================================================
task 2: Starting Order

the starting order is determined by the loop in the main (AccountManager.java)
		for(int i=0; i<10; i++){
			deposit[i].start();
			withdraw[i].start();
		}
a deposit thread is started and its corresponding withdraw thread is 
started immediately after.

if each thread has the chance to run uninterrupted in the CPU, then the data 
would not be corrupted (and about half the time, in sample runs, it 
is not). But some deposit threads are interrupted occasionally, and this results 
in the withdrawing thread being triggered before its corresponding deposit 
thread completes... then, in those few cases, data is corrupted.

In theory setting each corresponding deposit and withdraw thread as distant
as possible in execution would diminish the risk of getting corrupted data.
This is because the deposit would have more chances to complete before the
withdraw thread is completed.

test: the loop is modified with 2 loops instead:
		for(int i=0; i<10; i++){
			deposit[i].start();
		}
		for(int i=0; i<10; i++){
			withdraw[i].start();
		}
sample runs show that account data is still occasionally corrupted, although
it seems to be slightly less often than with the previous loop (statistics 
over a large number of samples would be required to have a good estimate
of the effect of this second loop).

...the difference, if it exists, is not very significant, though. it seems that, 
in practice a deposit process has almost as much risk to be interrupted 
by its corresponding process, even if there are 9 other processes that
separate them in the call order.

===================================================================================
task 3: Method level synchronization 

in the task 3 package I synchronized the methods:
	public void debosit(double amount){...}
	public void withdraw(double amount){...}
the result is:
	public synchronized void debosit(double amount){...}
	public synchronized void withdraw(double amount){...}
...account data are never corrupted anymore in sample runs.


===================================================================================
task 4: Block level synchronization (Synchronized statements)

added a lock object:
	private final Object LOCK = new Object(); // not static, but specific to 
					//each instance, each account object. 

embedded methods' critical sections in a synchronized(this.LOCK){...} block:
		synchronized (this.LOCK) {
			balance = balance + amount;
		}


===================================================================================
task 5

block synchronization is more flexible than method synchronization:

- block level allows to exclude some of the code in the method that does not need
to be atomic. here the code 
		double k = 999999999;
		for (int i = 0; i < 100; i++)
			k = k / 2;
can be safely excluded from the synchronized, critical section.

- block level allows to choos what object acts as lock. this allows for example
to share a lock among all instances of a class, by making it static. This is
however not needed in this specific assignment but could come in handy.

on the other hand method synchronization is perhaps clearer because it tags the 
method as critical/ atomic--easier to read for other programmers, thus better
for maintainability.





